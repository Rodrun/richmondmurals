{"version":3,"sources":["App.js","serviceWorker.js","index.js"],"names":["mapboxgl","accessToken","App","props","callBackendAPI","a","fetch","response","json","body","status","Error","message","state","data","lng","lat","zoom","map","Map","container","this","mapContainer","style","center","loadImage","error","image","addImage","addControl","GeolocateControl","positionOptions","enableHighAccuracy","trackUserLocation","on","setState","getCenter","toFixed","getZoom","forwardGeocoder","query","matchingFeatures","i","features","length","feature","properties","title","toLowerCase","includes","geometry","coordinates","push","getCanvas","cursor","then","res","type","murals","MapboxGeocoder","placeHolder","localGeocoder","addSource","addLayer","e","slice","desc","Math","abs","lngLat","Popup","setLngLat","setHTML","addTo","catch","err","console","log","className","ref","el","Component","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.a18c774b.chunk.js","sourcesContent":["import React, { Component } from 'react'\nimport 'mapbox-gl/dist/mapbox-gl.css'\nimport './App.css'\nimport mapboxgl from 'mapbox-gl'\nimport MapboxGeocoder from '@mapbox/mapbox-gl-geocoder'\n\nmapboxgl.accessToken = \"pk.eyJ1IjoianVhbm1lbmRnIiwiYSI6ImNrZGRqZ3F5YzFucm8ydXBkNmRraWVyZW4ifQ.fOgpbBWhLUa-hTut1Q5cRw\"\n\nclass App extends Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      data: null,\n      lng: -77.44,\n      lat: 37.53,\n      zoom: 10\n    }\n  }\n\n  componentDidMount() {\n    // Fun map setup and config\n    const map = new mapboxgl.Map({\n      container: this.mapContainer,\n      style: 'mapbox://styles/mapbox/streets-v11',\n      center: [this.state.lng, this.state.lat],\n      zoom: this.state.zoom\n    })\n\n    // Load marker image\n    map.loadImage(\n      'https://docs.mapbox.com/mapbox-gl-js/assets/custom_marker.png',\n      (error, image) => {\n        if (error) throw error\n          map.addImage('custom-marker', image)\n        }\n    )\n\n    // User's location\n    map.addControl(new mapboxgl.GeolocateControl({\n      positionOptions: {\n        enableHighAccuracy: true\n      },\n      trackUserLocation: true\n    }))\n\n    map.on('move', () => {\n      // Update coordinate/zoom state\n      this.setState({\n        lng: map.getCenter().lng.toFixed(4),\n        lat: map.getCenter().lat.toFixed(4),\n        zoom: map.getZoom().toFixed(2)\n      })\n    })\n\n    /**\n     * Handles geocoder searches.\n     */\n    let forwardGeocoder = (query) => {\n      var matchingFeatures = [];\n      for (var i = 0; i < this.state.data.features.length; i++) {\n        var feature = this.state.data.features[i];\n        if (feature.properties.title.toLowerCase().includes(query.toLowerCase())) {\n          feature['place_name'] = 'Mural:' + feature.properties.title\n          feature['center'] = feature.geometry.coordinates\n          feature['place_type'] = ['mural']\n          matchingFeatures.push(feature)\n        }\n      }\n      return matchingFeatures;\n    }\n\n    // Show mouse pointer over mural hover (points layer)\n    map.on('mouseenter', 'points', function() {\n      map.getCanvas().style.cursor = 'pointer'\n    })\n  \n    // Change it back to a pointer when it leaves.\n    map.on('mouseleave', 'points', function() {\n      map.getCanvas().style.cursor = ''\n    })\n\n    map.on('load', () => {\n      // Load mural data\n      this.callBackendAPI()\n        .then(res => {\n          // Update state with mural data\n          // TODO: Perhaps change the database document?\n          this.setState({ data:\n            {\n              type: 'FeatureCollection',\n              features: res.murals\n            }\n          })\n\n          // Geocoder search bar\n          map.addControl(new MapboxGeocoder({\n            accessToken: mapboxgl.accessToken,\n            placeHolder: 'Search',\n            localGeocoder: forwardGeocoder,\n            mapboxgl: mapboxgl\n          }))\n\n          // Add mural data as a source\n          map.addSource('murals', {\n            type: 'geojson',\n            data: this.state.data\n          })\n\n          // Add marker layer\n          map.addLayer({\n            'id': 'points',\n            'type': 'symbol',\n            'source': 'murals',\n            'layout': {\n              'icon-image': 'custom-marker',\n              // get the title name from the source's \"title\" property\n              'text-field': ['get', 'title'],\n              'text-font': [\n                'Open Sans Semibold',\n                'Arial Unicode MS Bold'\n              ],\n              'text-offset': [0, 1.25],\n              'text-anchor': 'top'\n            }\n          })\n\n          // Show popup on mural click\n          map.on('click', 'points', function(e) {\n            let coordinates = e.features[0].geometry.coordinates.slice()\n            let desc = e.features[0].properties.desc\n\n            // Ensure that if the map is zoomed out such that multiple\n            // copies of the feature are visible, the popup appears\n            // over the copy being pointed to.\n            while (Math.abs(e.lngLat.lng - coordinates[0]) > 180) {\n              coordinates[0] += e.lngLat.lng > coordinates[0] ? 360 : -360;\n            }\n\n            // TODO: Add more HTML besides the desc; i.e. share link, images\n            new mapboxgl.Popup()\n              .setLngLat(coordinates)\n              .setHTML(desc)\n              .addTo(map)\n          })\n        }) // then\n        .catch(err => console.log(err))\n    }) // on load\n  }\n\n  callBackendAPI = async () => {\n    const response = await fetch('/api/list')\n    const body = await response.json()\n\n    if (response.status !== 200) {\n      throw Error(body.message)\n    }\n    return body\n  }\n\n  render() {\n    return (\n      <div>\n        <div className=\"menubarStyle\"></div>\n        <div className=\"sidebarStyle\">\n          <div>Longitude: {this.state.lng} | Latitude: {this.state.lat} | Zoom: {this.state.zoom}</div>\n        </div>\n        <div ref={el => this.mapContainer = el} className={\"mapContainer\"} />\n      </div>\n    )\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}